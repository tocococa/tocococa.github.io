<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Git and GitFlow 101</title>
    <link rel="stylesheet" href="../css/tocococa.css">
</head>
<body>
    <div id="page">
        <h1>Git and GitFlow 101</h1>
        <p>
            This guide was written to lay out the basics of Git collaboration for some software projects to be done 
            collaboratively in the CIRS lab.
        </p>
        <p>
            To refresh your knowledge on Git usage and functionality, you can review 
            <a href="https://rogerdudler.github.io/git-guide/">this guide</a>.
        </p>
        <p>
            This guide takes inspiration from <a href="https://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a> 
            along with <a href="https://www.conventionalcommits.org/en/v1.0.0/">Conventional Commits</a> and is also loosely based on the Git flow that 
            we used while I was at Levita Magnetics. The one important distinction, is the use of <code>git rebase</code> before merging a feature 
            branch into a release or working branch, to avoid polluting the history of the repo. This is entirely a preference of the author and 
            open to debate.
        </p>

        <h2>Why?</h2>
        <p>
            Maintaining a standard Git flow allows for better control of the current software version, tracking development progress, seeing what 
            each team member is working on, keeping code more organized, and improving control over integration and validation of deliverables. 
            It also allows for other tools to be run with better results, such as <code>git bisect</code> or different kinds of automated tests.
        </p>

        <h2>How?</h2>
        <p>
            The workflow should mainly depend on two branches:
        </p>
        <ul>
            <li><code>origin/main</code>: this is where the code that runs during field tests and live trials. This version must be ready to be 
                deployed, used and (within reason) bug-free, with all its dependencies updated and well documented.</li>
            <li><code>origin/develop</code>: this is the development branch, on which functionality is added and the software progresses. This 
                branch should be used for dry or indoor water tests, and if ready to use, should be merged to main through a <strong>release</strong> branch.</li>
        </ul>

        <h2>Branching and merging</h2>
        <p>
            Creating a branch off another one is very simple, to create a new branch and move to it, run <code>git checkout -b &lt;branch_name&gt;</code>.
        </p>
        <p>
            Once you've done some changes, use <code>git add &lt;file1&gt; &lt;file2&gt;</code> to stage your changes. If you want to add all 
            changes and untracked files under the current directory, you can use <code>git add .</code> or if you want the same but for the whole 
            repo, (carefully) use <code>git add *</code>.
        </p>
        <p>
            Then to commit those changes to the HEAD of your local branch, run <code>git commit -m 'commit message'</code>. To update the remote 
            repository, run <code>git push</code>.
        </p>
        <p>
            Once you are ready to open a pull request you should <a href="https://www.atlassian.com/git/tutorials/merging-vs-rebasing">squash all 
            your commits and then rebase your branch</a>, to do this, first make sure your branch and any others are up to date by running 
            <code>git fetch --all --prune</code>, then to squash your changes w.r.t. merge-base, run <code>git rebase -i $(get merge-base HEAD @{u})</code>, 
            where <code>@{u}</code> should automatically pick up the name of the upstream branch. Then, in the text editor, for all commits except 
            the first, replace <code>pick</code> with <code>squash</code> or <code>s</code>, after that is done, you can also amend the commit message 
            with <code>reword</code> or remove a commit with <code>drop</code>. In this step, you might be prompted to solve any conflicts there might be.
        </p>
        <p>
            After you are done, save, exit and then run <code>git push --force</code>. It is very important that the <code>--force</code> flag is 
            given any time you push after a rebase, as we are rewriting the branch history and we want to update it in the remote too. You can now 
            go to your branch in GitLab or GitHub and create the pull request.
        </p>
        <p>
            While the PR is opened, any changes to the branch by yourself or other developers, should be done using <code>git merge</code>, to 
            preserve the history.
        </p>
        <p>
            Once the pull request is approved, if there were any intermediate commits, squash and rebase again, and then merge them into the 
            upstream with <code>git merge &lt;upstream&gt;</code>.
        </p>
        <p>
            There are three types of branches apart from <code>develop</code> and <code>main</code>:
        </p>
        <ol style="text-align: left;">
            <li>Feature branches</li>
            <li>Hotfix branches</li>
            <li>Release branches</li>
        </ol>

        <h3>Feature branches</h3>
        <p>
            These branches are used to develop repository features. Once this feature has been completed, the branch must be merged to 
            <code>origin/develop</code> <strong>through a Pull Request</strong>.
        </p>
        <p>
            They are branches from <code>develop</code> or another feature branch. They must merge to <code>develop</code>.
        </p>
        <p>
            They don't have a particular naming convention*, but names should be descriptive and use only hyphens, for example, 
            <code>holonomic-control</code>, <code>motor-driver</code> or <code>pathplanning-task</code>.
        </p>
        <p>
            Once the last push to <code>origin</code> has been made, a PR must be opened from BitBucket/GitHub and at least 2 people must be 
            marked as reviewers, who are not the author of the branch. The PR should not be merged unless there's approval from at least one 
            reviewer. Once the PR is accepted and merged, the associated branch should be deleted from <code>origin</code>.
        </p>
        <p>
            * If the repo were to be connected to an issue tracking system, it could require you to write the number of the ticket as part of 
            the branch name so that it can track the branch.
        </p>

        <h3>Release branches</h3>
        <p>
            These branches are used to test and validate all features created up to that moment, in preparation for a field test.
        </p>
        <p>
            They are branches from <code>develop</code>, and they must merge to <code>origin/develop</code> <strong>AND</strong> to 
            <code>origin/main</code>. Release branches <em>can</em> include new changes to the code, so it is important that they are then 
            merged back to develop, as to not mess up the commit history.
        </p>
        <p>
            The naming convention is <code>release-*</code>. These branches could also be tagged so that a version pipeline can run over them.
        </p>

        <h3>Hotfix branches</h3>
        <p>
            These branches are used in case a critical failure is detected during a field test.
        </p>
        <p>
            They are branches from <code>main</code>. They must merge to <code>origin/develop</code> <strong>AND</strong> to 
            <code>origin/main</code>.
        </p>
        <p>
            The naming convention is <code>hotfix-*</code>.
        </p>

        <h2>Commits</h2>
        <p>
            The naming convention for commits should be as follows:
        </p>
        <ul>
            <li><code>feat(*):*</code>: indicates that progress has been made on a particular feature, for example, <code>feat(task0 launch)</code> 
                could indicate that the Task 0 launch has been completed. This is the commit style that should be used most frequently in feature branches.</li>
            <li><code>fix(*):*</code>: indicates that a bug has been fixed, for example, <code>fix(vel 100 in reverse)</code> could indicate that 
                a bug where the throttle input always went at 100% power in reverse has been fixed.</li>
            <li><code>release(*):*</code>: indicates that a new release has been completed.</li>
            <li><code>BREAKING:*</code>: used when changes are added that could break functionality in <strong>other</strong> repositories, for 
                example, if the format of a message that must be sent by <code>nodeA</code> but received by <code>nodeB</code> under another repo 
                is modified, or a major dependency has been bumped to a newer version.</li>
        </ul>
        <p>
            These commits should be completed as follows:
        </p>
        <pre><code>&lt;type&gt;[scope]: &lt;description&gt;

[optional body]
</code></pre>
        <p>
            Where <code>type</code> is one of the previously mentioned types. <code>scope</code> broadly indicates what has been changed, 
            <code>description</code> can provide more details about what has been changed and <code>body</code> any other relevant information 
            worth mentioning.
        </p>

        <h2>Cheat sheet</h2>
        <p>
            Here are some common commands you might want to use:
        </p>
        <p>
            <code>git switch &lt;branchname&gt;</code> - move between branches.
        </p>
        <p>
            <code>git status</code> - see files which are not staged or committed, or what their status is.
        </p>
        <p>
            <code>git diff | &lt;branchname&gt;</code> - by itself, shows the diff of files changed but uncommitted or unstaged. If a branchname 
            is given, it will show the difference w.r.t. its local tip.
        </p>
        <p>
            <code>git commit -amend</code> - edit the commit message.
        </p>
        <p>
            <code>git reset --hard HEAD~1</code> - undo the last commit or merge and discard changes.
        </p>
        <p>
            <code>git reset --soft HEAD~1</code> - undo the last commit or merge and keep changes.
        </p>
        <p>
            <code>git reset --hard HEAD</code>, then <code>git pull</code> - remove all uncommitted changes and then pull remote tip into the 
            current branch.
        </p>
        <p>
            <code>git log</code> - lists the commit history.
        </p>
        <p>
            <code>git fetch -p</code> - sync the branch list.
        </p>

        <h2>bashrc settings</h2>
        <p>
            If you want your bash shell to show the current branch you're at, add the following in your <code>.bashrc</code> file:
        </p>
        <pre><code>parse_git_branch() {
     git branch 2&gt; /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ (\1)/'
}
export PS1="\[\033[01;32m\]\u@\h \[\033[34m\]\w\[\033[33m\]\$(parse_git_branch)\[\033[00m\] $ "
</code></pre>

        <footer>
            <a href="../index.html">Back home </a>
        </footer>

        <script src="https://utteranc.es/client.js"
            repo="tocococa/tocococa.github.io"
            issue-term="pathname"
            theme="github-dark"
            crossorigin="anonymous"
            async>
        </script>
        <script src="../js/background.js"></script>
    </div>
</body>
</html>
